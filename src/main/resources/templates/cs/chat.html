<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Chat</title>
    <!-- SockJS 클라이언트 라이브러리 비동기 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1.5.0/dist/sockjs.min.js" async></script>

    <!-- STOMP 클라이언트 라이브러리 비동기 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js" async></script>


</head>
<body>
<div id="messages"></div> <!-- 메시지를 보여주는 부분을 버튼 위로 이동 -->
<div id="categoryButtons">
    <!-- 카테고리 선택 버튼 -->
    <button onclick="selectCategory('예매')">예매</button>
    <button onclick="selectCategory('판매')">판매</button>
    <button onclick="selectCategory('이벤트')">이벤트</button>
    <button onclick="selectCategory('기타')">기타</button>
</div>
<div>
    <input type="text" id="message" placeholder="Type a message..."/>
    <button onclick="sendMessage()">Send</button>
    <div id="typingIndicatorDTO" style="display: none;">상대방이 채팅 중입니다.</div> <!-- 타이핑 인디케이터 표시 부분 추가 -->
</div>

<script th:inline="javascript">
    /*<![CDATA[*/
    var sender = /*[[${userEmail}]]*/ 'default@example.com'; // Thymeleaf를 통해 서버에서 userEmail을 전달받거나 기본값 설정
    /*]]>*/
    var chatRoomId = null;
    var chatRoomTitle = null;
    var recipient = null;  // 수신자 이메일을 고정
    var stompClient = null; // STOMP 클라이언트 변수 선언
    var typingTimeout = null; //타이핑 타이머
    var TYPING_DELAY = 3000; // 타이핑 상태 업데이트를 위한 딜레이 시간 (3초)
    var typingIndicatorSent = false; // 타이핑 상태가 이미 전송되었는지 여부를 저장하는 변수
    var status = null; //채팅방 상태
    var entranceStatus  = "exit"; //관리자의 입장상태

    // 초기 페이징 값 설정
    var activePage = 1;
    var inactivePage = 1;

    // WebSocket 연결 함수
    function connect() {
        var socket = new SockJS('/ws');
        stompClient = Stomp.over(socket);
        stompClient.connect({}, function (frame) {
            // 연결 성공 시 콘솔에 로그 출력
            console.log('Connected: ' + frame);
            // 타이핑 이벤트를 감지하여 서버로 전송
            document.getElementById('message').addEventListener('input', handleTypingEvent);
            // 특정 사용자 큐에 구독 (개인 메시지 수신)
            stompClient.subscribe('/user/queue/private/' + chatRoomId, function (message) {
                var parsedMessage = JSON.parse(message.body);
                console.log("Message " + JSON.stringify(parsedMessage));

                handleMessage(parsedMessage);
            })
            // 전체 메시지를 받기 위해 토픽 구독
            stompClient.subscribe('/Topic/paging', function (message) {
                var parsedMessage = JSON.parse(message.body);
                console.log("Broadcast Message " + JSON.stringify(parsedMessage));

                // 메시지 받을 때마다 페이징 값 업데이트
                activePage = parsedMessage.activePage;
                inactivePage = parsedMessage.inactivePage;

                handleMessage(parsedMessage);
            });
        });
    }

    // 메시지 타입에 따른 처리
    function handleMessage(parsedMessage) {

        //채팅종료 시
        if (parsedMessage.status === 'inactive') {
            console.log("대화종료메세지오기전에");
            showMessage(parsedMessage.content);
            showMessage('다른 문의가 있으면 카테고리를 선택해주세요.');
            updateCategoryButtonsDisplay('block');
            //일반 메세지
        } else if (parsedMessage.status === 'active') {
            console.log("일반메세지.");
            showMessage('관리자 : ' + parsedMessage.content);
            //타이핑 중이면
        } else if (parsedMessage.typing === "typing") {
            console.log("상대방이 타이핑 중입니다.");
            updateTypingIndicatorDisplay('block');
            //타이핑 안할 때
        } else if (parsedMessage.typing === "not_typing") {
            console.log("채팅안함");
            updateTypingIndicatorDisplay('none');
        } else {
            entranceStatus = parsedMessage.type;
            console.log("관리자 상태" +entranceStatus);
        }
    }

    //카테고리 활성화
    function updateCategoryButtonsDisplay(displayStyle) {
        document.getElementById('categoryButtons').style.display = displayStyle;
    }

    //입력창 활성화
    function updateTypingIndicatorDisplay(displayStyle) {
        document.getElementById('typingIndicatorDTO').style.display = displayStyle;
    }

    // 타이핑 이벤트를 처리하는 함수
    function handleTypingEvent() {
        // 처음 입력 시 타이핑 상태 전송
        if (!typingIndicatorSent) {
            const type = "typing";
            sendTypingIndicator(type);
            typingIndicatorSent = true;
        }
        // 기존 타이머 제거
        clearTimeout(typingTimeout);

        typingTimeout = setTimeout(function () {

            const type = "not_typing";
            sendTypingIndicator(type); // 사용자가 일정 시간 입력을 멈추면 타이핑 상태 전송
            typingIndicatorSent = false; // 타이핑 상태 초기화
        }, TYPING_DELAY);
    }

    // 타이핑 인디케이터를 서버로 전송하는 함수
    function sendTypingIndicator(type) {
        var typingIndicatorDTO = {
            chatRoomId: chatRoomId,
            sender: sender,
            recipient: recipient,
            typing: type,
        };
        stompClient.send("/app/chat/typing", {}, JSON.stringify(typingIndicatorDTO));
    }

    // 메시지 전송 함수
    function sendMessage() {
        var messageContent = document.getElementById('message').value;
        console.log("메세지전송의 ChatRoomId" + chatRoomId)
        console.log("메세지전송의 recipient" + recipient)

        // 메시지 내용이 없으면 함수 종료
        if (!messageContent) return;

        var message = {
            chatRoomId: chatRoomId,
            sender: sender,
            recipient: recipient,
            content: messageContent,
            chatRoomTitle: chatRoomTitle,
            status: "active",
            paging: {
                activePage: activePage,
                inactivePage: inactivePage
            }
        };

        stompClient.send("/app/chat/private", {}, JSON.stringify(message)); // STOMP를 통해 서버로 메시지 전송
        showMessage('나 : ' + messageContent); // 전송한 메시지를 화면에 표시
        document.getElementById('message').value = ''; // 입력 필드를 비움

 

        // 메시지 전송 후 타이핑 상태 초기화
        clearTimeout(typingTimeout);
        typingIndicatorSent = false;
    }

    // Enter 키 입력 시 메시지 전송
    document.getElementById("message").addEventListener("keydown", function (event) {
        if (event.key === "Enter") {
            event.preventDefault(); // Enter 키의 기본 동작(새 줄 추가)을 막음
            sendMessage(); // sendMessage 함수 호출
        }
    });

    //메세지 표현
    function showMessage(message) {
        var messages = document.getElementById('messages');
        var messageElement = document.createElement('p');
        messageElement.appendChild(document.createTextNode(message));
        messages.appendChild(messageElement);
        document.getElementById('typingIndicatorDTO').style.display = 'none';
    }

    //카테고리를 선택한 후
    function selectCategory(category) {
        console.log("선택한 category" + category)

        var messages = document.getElementById('messages');
        // messages 요소의 자식 노드를 모두 제거
        while (messages.firstChild) {
            messages.removeChild(messages.firstChild);
        }

        chatRoomTitle = category;
        showMessage('문의사항을 남겨주시면 신속히 답변해드리겠습니다.');

        // 카테고리 버튼 숨기기
        document.getElementById('categoryButtons').style.display = 'none';

        //카테고리 별 수신자 이메일 설정
        switch (category) {
            case '예매':
                recipient = '1@admin.com';
                break;
            case '판매':
                recipient = '2@admin.com';
                break;
            case '이벤트':
                recipient = '3@admin.com';
                break;
            case '기타':
                recipient = '4@admin.com';
                break;
            default:
                recipient = 'admin@admin.com';
        }
        createChatRoomAndConnect(recipient, category);
    }

    //관리자이메일과 카테고리로 채팅방 생성
    function createChatRoomAndConnect(recipient, category) {
        console.log("sender" + sender);
        // 채팅방 생성 및 연결 요청
        fetch('/chat/createChatRoom', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({adminEmail: recipient, userEmail: sender, chatRoomTitle: category})
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok ' + response.statusText);
                }
                return response.json(); // 서버 응답을 JSON 형식으로 파싱
            })
            .then(data => {
                chatRoomId = data.chatRoomId; // 서버 응답에서 채팅방 ID 추출
                // 채팅방 생성 후 연결
                connect();
            })
            .catch(error => console.error('Error creating chat room:', error));
    }

    //유저이메일로 현재 채팅중인 관리자 이메일 찾기
    async function fetchRecipientEmail() {
        try {
            const response = await fetch('/chat/getRecipientEmail');
            const data = await response.json(); // JSON 형식으로 응답을 파싱
            return Array.isArray(data) ? data[0] : data || '이메일을 찾을 수 없습니다.';
        } catch (error) {
            console.error('오류:', error);
            return '오류 발생';
        }
    }

    //관리자 이메일로 채팅중인 채팅룸반환
    async function fetchMessages(recipient) {
        console.log("fetchMessages의 recipient: " + recipient);
        try {
            const response = await fetch(`/chat/active/${recipient}`);
            if (!response.ok) {
                throw new Error('Network response was not ok ' + response.statusText);
            }
            const data = await response.json();

            console.log("data: " + JSON.stringify(data, null, 2));
            if (Array.isArray(data) && data.length > 0) {
                chatRoomId = data[0].id;
            }
            let messageExist = false;
            let unreadMessageFlag = false;

            // 각 메시지 객체를 순회
            data.forEach(item => {
                let lastReadTimestamp = parseInt(localStorage.getItem(`lastReadTimestamp_${chatRoomId}`), 10) || 0;

                if (Array.isArray(item.messages) && item.messages.length > 0) {
                    messageExist = true;
                    item.messages.forEach(message => {
                        let messageTimestamp = new Date(message.createAt).getTime();

                        console.log("로컬읽은 시간:", lastReadTimestamp);
                        console.log("메세지 생성시간:", messageTimestamp);

                        if (messageTimestamp > lastReadTimestamp && !unreadMessageFlag && messageExist) {
                            console.log("이전 메시지입니다");
                            showMessage('----------이전 메시지입니다 ----------');
                            unreadMessageFlag = true;
                        }


                        recipient = message.sender;
                        chatRoomTitle = message.chatRoomTitle;
                        document.getElementById('categoryButtons').style.display = 'none';
                        let displayMessage = message.sender === sender ? `나 : ${message.content}` : `관리자 : ${message.content}`;

                        showMessage(displayMessage);
                    });

                }
            });



            // 메시지가 없을 경우에만 카테고리 메시지를 표시
            if (!messageExist) {
                showMessage('안녕하세요 고객님 카테고리를 선택해주세요');
            } else if (chatRoomTitle === '상담이 완료되었습니다.') {
                document.getElementById('categoryButtons').style.display = 'block';
            }
        } catch (error) {
            console.error('Error fetching messages:', error);
        }
    }
</script>
<script type="module">
    import {connectWebSocket, updateUnreadCount} from '/modules/chatModule.js';

    document.addEventListener('DOMContentLoaded', function () {
        console.log("모달연결")
        // WebSocket 연결 설정
        setupWebSocketConnection();
    });

    //웹소켓 옵션
    function setupWebSocketConnection() {
        const options = {
            subscribeCallback: handleWebSocketMessage
        };

        // WebSocket 연결 함수 호출
        connectWebSocket(options);
    }

    //안읽은 메세지수 업데이트
    function handleWebSocketMessage(response) {
        updateUnreadCount(response);
    }
</script>
</body>
</html>