<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- SockJS 클라이언트 라이브러리 비동기 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1.5.1/dist/sockjs.min.js"></script>

    <!-- STOMP 클라이언트 라이브러리 비동기 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>

    <!-- chatMessageCount.js 파일 추가 -->
    <!--    <script src="/modules/chatMessageCount.js" type="module"></script>-->
    <title>Event List</title>
    <style>
        .modal {
            display: none; /* 기본적으로 모달을 숨김 */
            position: fixed;
            z-index: 99999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100vh; /* 모달 창의 높이를 화면 전체로 설정 */
            background-color: rgba(0, 0, 0, 0.4); /* 반투명 배경 */
            padding-top: 60px;
        }


        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-height: 60vh; /* 모달 내용의 최대 높이 설정 */
            overflow-y: auto; /* 내용이 넘칠 경우 스크롤 생성 */
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        td, th {
            padding: 15px;
        }
    </style>
</head>
<body>
<!-- Navbar 생략 -->
<div class="card">
    <h5 class="card-header">Event List</h5>
    <div class="table-responsive text-nowrap">
        <table class="table table-hover">
            <thead>
            <tr>
                <th>방 번호</th>
                <th>카테고리</th>
                <th>메세지</th>
                <th>회원 이메일</th>
                <th>회원 이름</th>
            </tr>
            </thead>
            <tbody class="chat-table">
            <!-- 데이터는 자바스크립트로 동적으로 추가됩니다 -->
            </tbody>
        </table>
        <!-- 페이지네이션 -->
        <div id="pagination"></div>
    </div>
</div>
<div id="myModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeModal()">&times;</span>
        <div id="userEmail"></div> <!-- 유저 이메일 표시 부분 추가 -->
        <div id="messages"></div>
        <div>
            <input type="text" id="message" placeholder="Type a message..."/>
            <button onclick="sendMessage()">Send</button>
            <button onclick="sendEndChatMessage()">대화 종료</button>
            <div id="typingIndicatorDTO" style="display: none;">상대방이 채팅 중입니다.</div> <!-- 타이핑 인디케이터 표시 부분 추가 -->
        </div>
    </div>
</div>
<!-- 모달 -->
<script type="module">

    import { updateTimeSinceCreated } from '/modules/timeSinceCreated.js'; //시간 경과 모듈

    import {
        loadChatList,
        connectWebSocket,
        displayChatList,
        updateUnreadCount,
        adminEmail,
    } from '/modules/chatMessageCount.js';

    $(document).ready(async function () {
        memberEmail = adminEmail;
        let stompClient = null; // 전역 변수로 선언
        // 옵션 객체 정의
        const options2 = {
            subscribeCallback: handleWebSocketMessage, // 메시지를 받았을 때 호출할 콜백 함수 지정
            displayChatListCallback: displayChatList, // 채팅 목록을 화면에 표시할 콜백 함수로 displayChatList 함수를 지정
            loadInitialData: loadInitialChatList, // 초기 데이터 로드 함수로 loadInitialChatList 지정
            initialDataParams: [1, 8, false] // 초기 데이터 로드 파라미터
        };

        // 웹소켓 연결
        stompClient = await connectWebSocket(options2);

        updateTimeSinceCreated(); // 웹소켓 연결 후 updateTimeSinceCreated() 호출

        // 페이지를 떠날 때 웹소켓 연결 해제
        $(window).on('beforeunload', function () {
            if (stompClient !== null) {
                stompClient.disconnect();
            }
        });

        // 최초 데이터 로드 함수 정의
        async function loadInitialChatList(page, size, isUpdateUnreadCountOnly) {
            await loadChatList(page, size, isUpdateUnreadCountOnly);
        }

        console.log("준비끝남")
    });

    //웹소켓으로부터 메시지를 받았을 때 호출되는 콜백 함수
    function handleWebSocketMessage(response) {
        displayChatList(response);  //화면에 표시
        updateUnreadCount(response); //않은 메시지 수를 업데이트
    }

    // 클릭된 페이지에 대한 채팅 목록 로드
    $(document).on('click', '.paging-btn', function (e) {
        e.preventDefault();

        const currentPage = $(this).data('page');
        console.log("클릭한 페이지 " + currentPage)
        loadChatList(currentPage, 8, false); // 페이지 크기는 8로 설정
    });
</script>

<script>
    var memberEmail = '';
    var currentRecipient = ''; // 전역 변수로 선언
    var chatRoomTitle = '';
    var chatRoomId = '';
    var isConnected = false;
    var stompClient = null; // STOMP 클라이언트 변수 선언
    var typingTimeout = null;
    var TYPING_DELAY = 3000; // 타이핑 상태 업데이트를 위한 딜레이 시간 (3초)
    var typingIndicatorSent = false;  // 타이핑 상태가 이미 전송되었는지 여부를 저장하는 변수
    var status = null;

    // DOM 요소를 가져오는 함수
    function getElement(id) {
        return document.getElementById(id);
    }

    // 메시지를 표시하는 함수
    function showMessage(message) {
        const messages = getElement('messages');
        const messageElement = document.createElement('p');
        messageElement.className = 'message-style'; // 메시지 스타일 클래스 추가
        messageElement.textContent = message;
        messages.appendChild(messageElement);
        document.getElementById('typingIndicatorDTO').style.display = 'none';
    }

    // Stomp 연결 함수
    function connect() {
        if (isConnected) return;
        console.log("currentchatRoomTitle" + currentRecipient);

        var socket = new SockJS('/ws');
        stompClient = Stomp.over(socket);
        stompClient.connect({}, function (frame) {
            console.log('Connected: ' + frame);
            subscribeToRecipient();
            // 타이핑 이벤트를 감지하여 서버로 전송
            document.getElementById('message').addEventListener('input', handleTypingEvent);

        });
        isConnected = true;
    }

    // 수신자 구독
    function subscribeToRecipient() {
        stompClient.subscribe('/user/queue/private/' + chatRoomId, function (message) {
            console.log("Private Message: " + message.body);

            document.getElementById('message').disabled = false;
            var parsedMessage = JSON.parse(message.body);

            chatRoomTitle = parsedMessage.chatRoomTitle;

            console.log("chatRoomTitle" + chatRoomTitle);
            currentRecipient = parsedMessage.sender;

            if (parsedMessage.typing === "typing") {
                // 상대방이 타이핑 중임을 표시하는 UI 업데이트 등을 수행
                showTypingIndicator();
            } else if (parsedMessage.typing === "not_typing") {
                hideTypingIndicator();
            } else {
                showMessage(parsedMessage.sender + ': ' + parsedMessage.content);
            }
        });
    }

    // 연결 해제 함수
    function disconnect() {
        if (stompClient !== null) {
            stompClient.disconnect();
        }
        isConnected = false;
    }

    // 메시지 전송 함수
    function sendMessage() {
        var messageContent = getElement('message').value;
        if (messageContent && currentRecipient) {
            var message = {
                chatRoomId: chatRoomId,
                sender: memberEmail,
                recipient: currentRecipient,
                content: messageContent,
                status: "active"
            };
            console.log("Sending message:", message);
            stompClient.send("/app/chat/private", {}, JSON.stringify(message));
            showMessage('관리자 : ' + messageContent);
            getElement('message').value = '';

            // 메시지 전송 후 타이핑 상태 초기화
            clearTimeout(typingTimeout);
            typingIndicatorSent = false;
        }
    }

    // Enter 키 입력 시 메시지 전송
    document.getElementById("message").addEventListener("keydown", function (event) {
        if (event.key === "Enter") {
            event.preventDefault(); // Enter 키의 기본 동작(새 줄 추가)을 막음
            sendMessage(); // sendMessage 함수 호출
        }
    });

    // 타이핑 이벤트를 처리하는 함수
    function handleTypingEvent() {

        if (!typingIndicatorSent) {
            const type = "typing";
            sendTypingIndicator(type); // 처음 입력 시 타이핑 상태 전송
            typingIndicatorSent = true;
        }

        clearTimeout(typingTimeout); // 기존 타이머 제거

        typingTimeout = setTimeout(function () {
            const type = "not_typing";
            sendTypingIndicator(type); // 사용자가 일정 시간 입력을 멈추면 타이핑 상태 전송
            typingIndicatorSent = false; // 타이핑 상태 초기화
        }, TYPING_DELAY);
    }

    // 타이핑 인디케이터 전송 함수
    function sendTypingIndicator(type) {
        var typingIndicatorDTO = {
            chatRoomId: chatRoomId,
            sender: memberEmail,
            recipient: currentRecipient,
            typing: type
        };
        stompClient.send("/app/chat/typing", {}, JSON.stringify(typingIndicatorDTO));
    }

    // 종료 메시지 전송 함수
    function sendEndChatMessage() {
        console.log("메세지종료 chatRoomId" + chatRoomId)
        var endUserChatMessage = {
            chatRoomId: chatRoomId,
            sender: memberEmail,
            recipient: currentRecipient,
            content: '상담이 완료되었습니다.',
            status: "inactive"
        };

        console.log("Sending end chat message:", endUserChatMessage);
        stompClient.send("/app/chat/private", {}, JSON.stringify(endUserChatMessage));
        // 연결종료
        disconnect();
        // 관리자 측 채팅창에도 메시지 표시
        showMessage(endUserChatMessage.content);
        //입력필드 비활성화
        document.getElementById('message').disabled = true;
    }

    // 메시지 가져오기 함수
    function fetchMessages(chatRoomId) {

        console.log("chatRoomId 클릭한 " + chatRoomId);
        fetch(`/chat/clickChat/${chatRoomId}`)
            .then(response => {
                if (!response.ok) throw new Error('Network response was not ok ' + response.statusText);
                return response.json();
            })
            .then(data => {
                console.log('Data:', data);

                // 메시지 표시
                data.forEach(item => {
                    item.messages.forEach(message => {
                        // chatRoomTitle이 "endChat"이 아닌 메시지만 화면에 표시
                        if (message.chatRoomTitle !== "endChat") {
                            let displayMessage = message.recipient === currentRecipient ? `관리자 : ${message.content}` : `${message.sender} : ${message.content}`;
                            showMessage(displayMessage);
                        }
                    });
                });

                // 상태가 "active"일 때 입력창 활성화
                document.getElementById('message').disabled = !data.some(item => item.type === "active");
            })
            .catch(error => console.error('Error fetching messages:', error));
    }

    // function updateLastReadTimestamp(chatRoomId) {
    //     return fetch(`/chat/updateLastReadTimestamp/${chatRoomId}`, {
    //         method: 'POST',
    //         headers: {
    //             'Content-Type': 'application/json'
    //         }
    //     })
    //         .then(response => {
    //             if (!response.ok) {
    //                 throw new Error('Network response was not ok ' + response.statusText);
    //             }
    //             console.log("Last read timestamp updated successfully.");
    //         })
    //         .catch(error => {
    //             console.error('Error updating last read timestamp:', error);
    //             throw error; // Promise 체인을 끊어 에러를 상위로 전파
    //         });
    // }

    // 타이핑 인디케이터를 보여주는 함수
    function showTypingIndicator() {
        document.getElementById('typingIndicatorDTO').style.display = 'block'; // 타이핑 인디케이터 표시

    }

    // 타이핑 인디케이터를 숨기는 함수
    function hideTypingIndicator() {
        document.getElementById('typingIndicatorDTO').style.display = 'none'; // 타이핑 인디케이터 숨김
    }

    // 채팅 모달 열기 함수
    function openChatModal(row) {

        chatRoomId = row.getAttribute('data-room-id');
        currentRecipient = row.querySelector('td:nth-child(4)').innerText; // 현재 수신자 업데이트
        getElement('messages').innerHTML = ''; // 메시지 요소 초기화

        // if (isConnected) {
        //     disconnect(); // 이미 연결된 경우, 연결 해제
        // }

        fetchMessages(chatRoomId);
        connect();
        const modal = getElement('myModal');
        getElement('userEmail').innerText = currentRecipient;
        modal.style.display = 'block';
    }

    // 채팅 모달 닫기 함수
    function closeModal() {
        //모달창 열었을 때도 사이브바에 있는 1:1문의 갯수도 업데이트되도록해야함
        //updateLastReadTimestamp 실행 후 리스트업데이트
        window.chatUtils.updateLastReadTimestamp(chatRoomId)
            .then(() => {
                window.chatUtils.loadChatList(1, 8, false);
            })
            .catch(error => {
                console.error('Error updating last read timestamp:', error);
            });


        // 비동기 작업 외에 필요한 동기적인 작업들
        currentRecipient = '';
        const modal = getElement('myModal');
        modal.style.display = 'none';
        disconnect();

        console.log('loadChatList 함수 호출됨');

    }

    window.closeModal = closeModal;
    window.openChatModal = openChatModal;


</script>

</body>
</html>