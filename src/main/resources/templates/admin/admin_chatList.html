<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<!-- Navbar -->
<nav class="layout-navbar container-fluid navbar navbar-expand-xl navbar-detached align-items-center bg-navbar-theme"
     id="layout-navbar" style="margin-bottom: 10px;">
    <div class="navbar-nav-right d-flex align-items-center" id="navbar-collapse">
        <!-- Search -->
        <div class="navbar-nav align-items-center">
            <div class="nav-item d-flex align-items-center">
                <i class="bx bx-search fs-4 lh-0"></i>
                <input
                        aria-label="Search..."
                        class="form-control border-0 shadow-none"
                        placeholder="Search..."
                        type="text"
                />
            </div>
        </div>
    </div>
</nav>

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- SockJS 클라이언트 라이브러리 비동기 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1.5.1/dist/sockjs.min.js"></script>

    <!-- STOMP 클라이언트 라이브러리 비동기 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>

    <title>Event List</title>
    <style>
        .modal {
            display: none; /* 기본적으로 모달을 숨김 */
            position: fixed;
            z-index: 99999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100vh; /* 모달 창의 높이를 화면 전체로 설정 */
            background-color: rgba(0, 0, 0, 0.4); /* 반투명 배경 */
            padding-top: 60px;
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-height: 60vh; /* 모달 내용의 최대 높이 설정 */
            overflow-y: auto; /* 내용이 넘칠 경우 스크롤 생성 */
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        td, th {
            padding: 15px;
        }
    </style>
</head>
<body>
<!-- Navbar 생략 -->
<div class="row">
    <div class="col">
        <div class="card">
            <h5 class="card-header">Active Chat Rooms</h5>
            <div class="table-responsive text-nowrap">
                <table class="table table-hover">
                    <thead>
                    <tr>
                        <th>방 번호</th>
                        <th>카테고리</th>
                        <th>메세지</th>
                        <th>회원 이메일</th>
                        <th>회원 이름</th>
                    </tr>
                    </thead>
                    <tbody class="active-chat-table">
                    <!-- 활성 채팅방은 동적으로 추가 -->
                    </tbody>
                </table>
                <!-- 활성 채팅방 페이지네이션 -->
                <div id="active-pagination"></div>
            </div>
        </div>
    </div>
    <div class="col">
        <div class="card">
            <h5 class="card-header">Inactive Chat Rooms</h5>
            <div class="table-responsive text-nowrap">
                <table class="table table-hover">
                    <thead>
                    <tr>
                        <th>방 번호</th>
                        <th>카테고리</th>
                        <th>메세지</th>
                        <th>회원 이메일</th>
                        <th>회원 이름</th>
                    </tr>
                    </thead>
                    <tbody class="inactive-chat-table">
                    <!-- 비활성 채팅방은 동적으로 추가됩니다 -->
                    </tbody>
                </table>
                <!-- 비활성 채팅방 페이지네이션 -->
                <div id="inactive-pagination"></div>
            </div>
        </div>
    </div>
</div>

<div id="myModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeModal()">&times;</span>
        <div id="userEmail"></div> <!-- 유저 이메일 표시 부분 추가 -->
        <div id="messages"></div>
        <div>
            <input type="text" id="message" placeholder="Type a message..."/>
            <button onclick="sendMessage()">Send</button>
            <button onclick="sendEndChatMessage()">대화 종료</button>
            <div id="typingIndicatorDTO" style="display: none;">상대방이 채팅 중입니다.</div> <!-- 타이핑 인디케이터 표시 부분 추가 -->
        </div>
    </div>
</div>
<!-- 모듈 -->
<script type="module">

    import {updateTimeSinceCreated} from '/modules/timeSinceCreated.js'; //시간 경과 모듈

    import {
        connectWebSocket,
        displayChatList,
        updateUnreadCount,
        adminEmail,
    } from '/modules/chatModule.js';

    $(document).ready(async function () {
        memberEmail = adminEmail //관리자 이메일
        console.log("로드할때의 샌더이메일 " + memberEmail)
        let stompClient = null; // 전역 변수로 선언

        // 옵션 객체 정의
        const options2 = {
            subscribeCallback: handleWebSocketMessage, // 메시지를 받았을 때 호출할 콜백 함수 지정
            displayChatListCallback: displayChatList, // 채팅 목록을 화면에 표시할 콜백 함수로 displayChatList 함수를 지정
            initialDataParams: [1, 1, 8, false] // 초기 데이터 로드 파라미터
        };

        // 웹소켓 연결
        stompClient = await connectWebSocket(options2);
        // 웹소켓 연결 후 경과시간모듈 호출
        updateTimeSinceCreated();

        // 페이지를 떠날 때 웹소켓 연결 해제
        $(window).on('beforeunload', function () {
            if (stompClient !== null) {
                stompClient.disconnect();
            }
        });
    });

    //웹소켓으로부터 메시지를 받았을 때 호출되는 콜백 함수
    function handleWebSocketMessage(response) {
        displayChatList(response);  //화면에 표시
        updateUnreadCount(response); //않은 메시지 수를 업데이트
    }
</script>

<script>
    var memberEmail = ''; //로그인유저 이메일
    var currentRecipient = ''; //받는 사람이메일
    var chatRoomTitle = ''; //카테고리
    var chatRoomId = ''; //채팅룸번호
    var isConnected = false; //웹소켓 연결확인
    var stompClient = null; // STOMP 클라이언트 변수 선언
    var typingTimeout = null; //타이핑 타이머
    var TYPING_DELAY = 3000; // 타이핑 상태 업데이트를 위한 딜레이 시간 (3초)
    var typingIndicatorSent = false;  // 타이핑 상태가 이미 전송되었는지 여부를 저장하는 변수
    var status = null; //채팅방 상태
    var activePage = 1; //활성화 페이징번호
    var inactivePage = 1; //비활성화 페이징번호

    // DOM 요소를 가져오는 함수
    function getElement(id) {
        return document.getElementById(id);
    }

    // 메시지를 표시하는 함수
    function showMessage(message) {
        document.getElementById('typingIndicatorDTO').style.display = 'none';
        const messages = getElement('messages');
        const messageElement = document.createElement('p');

        messageElement.className = 'message-style'; // 메시지 스타일 클래스 추가
        messageElement.textContent = message;
        messages.appendChild(messageElement);

        activePage = window.chatUtils.activePage;
        inactivePage = window.chatUtils.inactivePage;
        window.chatUtils.updateLastReadTimestamp(chatRoomId, activePage, inactivePage); // 페이징 번호 전달
    }

    // Stomp 연결 함수
    function connect() {
        if (isConnected) return;

        var socket = new SockJS('/ws');
        stompClient = Stomp.over(socket);
        stompClient.connect({}, function (frame) {
            console.log('Connected: ' + frame);
            subscribeToRecipient();
            sendAdminEnter();
            // 타이핑 이벤트를 감지하여 서버로 전송
            document.getElementById('message').addEventListener('input', handleTypingEvent);
        });
        isConnected = true;
    }

    // 수신자 구독
    function subscribeToRecipient() {
        stompClient.subscribe('/user/queue/private/' + chatRoomId, function (message) {

            console.log("Private Message: " + message.body);
            document.getElementById('message').disabled = false;

            var parsedMessage = JSON.parse(message.body);
            chatRoomTitle = parsedMessage.chatRoomTitle;
            currentRecipient = parsedMessage.sender;

            if (parsedMessage.typing === "typing") {  //상대방이 타이핑 중일때
                showTypingIndicator();
            } else if (parsedMessage.typing === "not_typing") { //상대방이 타이핑 안할때
                hideTypingIndicator();
            } else {  //일반 메세지일때
                showMessage(parsedMessage.sender + ': ' + parsedMessage.content);
            }
        });
    }
    // 관리자가 채팅방에 입장했다는 알림을 전송
    function sendAdminExit() {
        console.log("채팅방나감")
        const EnterNotification = {
            chatRoomId: chatRoomId,
            recipient: currentRecipient,
            type: 'exit'
        };
        stompClient.send("/app/chat/admin/enter", {}, JSON.stringify(EnterNotification));
    }

    // 관리자가 채팅방에 입장했다는 알림을 전송
    function sendAdminEnter() {
        const EnterNotification = {
            chatRoomId: chatRoomId,
            recipient: currentRecipient,
            type: 'enter'
        };
        stompClient.send("/app/chat/admin/enter", {}, JSON.stringify(EnterNotification));
    }
    // 메시지 전송 함수
    function sendMessage() {
        var messageContent = getElement('message').value;
        if (messageContent && currentRecipient) {
            var message = {
                chatRoomId: chatRoomId,
                sender: memberEmail,
                recipient: currentRecipient,
                content: messageContent,
                status: "active"
            };
            console.log("Sending message:", message);
            stompClient.send("/app/chat/private", {}, JSON.stringify(message));
            showMessage('관리자 : ' + messageContent);
            getElement('message').value = '';

            // 메시지 전송 후 타이핑 상태 초기화
            clearTimeout(typingTimeout);
            typingIndicatorSent = false;
        }
    }

    // Enter 키 입력 시 메시지 전송
    document.getElementById("message").addEventListener("keydown", function (event) {
        if (event.key === "Enter") {
            event.preventDefault();
            sendMessage();
        }
    });

    // 타이핑 이벤트를 처리하는 함수
    function handleTypingEvent() {

        // 처음 입력 시 타이핑 상태 전송
        if (!typingIndicatorSent) {
            const type = "typing";
            sendTypingIndicator(type);
            typingIndicatorSent = true;
        }

        // 기존 타이머 제거
        clearTimeout(typingTimeout);

        typingTimeout = setTimeout(function () {
            const type = "not_typing";
            sendTypingIndicator(type); // 사용자가 일정 시간 입력을 멈추면 타이핑 상태 전송
            typingIndicatorSent = false; // 타이핑 상태 초기화
        }, TYPING_DELAY);
    }

    // 타이핑 인디케이터 전송 함수
    function sendTypingIndicator(type) {
        var typingIndicatorDTO = {
            chatRoomId: chatRoomId,
            sender: memberEmail,
            recipient: currentRecipient,
            typing: type
        };
        stompClient.send("/app/chat/typing", {}, JSON.stringify(typingIndicatorDTO));
    }

    // 종료 메시지 전송 함수
    function sendEndChatMessage() {
        console.log("메세지종료 chatRoomId" + chatRoomId)
        var endUserChatMessage = {
            chatRoomId: chatRoomId,
            sender: memberEmail,
            recipient: currentRecipient,
            content: '상담이 완료되었습니다.',
            status: "inactive"
        };

        console.log("Sending end chat message:", endUserChatMessage);
        stompClient.send("/app/chat/private", {}, JSON.stringify(endUserChatMessage));
        // 연결종료
        disconnect();
        // 관리자 측 채팅창에도 메시지 표시
        showMessage(endUserChatMessage.content);
        //입력필드 비활성화
        document.getElementById('message').disabled = true;
    }

    // 메시지 가져오기 함수
    function fetchMessages(chatRoomId) {

        fetch(`/chat/clickChat/${chatRoomId}`)
            .then(response => {
                if (!response.ok) throw new Error('Network response was not ok ' + response.statusText);
                return response.json();
            })
            .then(data => {
                data.forEach(item => {
                    item.messages.forEach(message => {
                        // chatRoomTitle이 "endChat"이 아닌 메시지만 화면에 표시
                        if (message.chatRoomTitle !== "endChat") {
                            let displayMessage = message.recipient === currentRecipient ? `관리자 : ${message.content}` : `${message.sender} : ${message.content}`;
                            showMessage(displayMessage);
                        }
                    });
                });

                // 상태가 "active"일 때 입력창 활성화
                document.getElementById('message').disabled = !data.some(item => item.type === "active");
            })
            .catch(error => console.error('Error fetching messages:', error));
    }

    // 타이핑 인디케이터를 보여주는 함수
    function showTypingIndicator() {
        document.getElementById('typingIndicatorDTO').style.display = 'block'; // 타이핑 인디케이터 표시

    }

    // 타이핑 인디케이터를 숨기는 함수
    function hideTypingIndicator() {
        document.getElementById('typingIndicatorDTO').style.display = 'none'; // 타이핑 인디케이터 숨김
    }

    // 채팅 모달 열기 함수
    function openChatModal(row) {
        chatRoomId = row.getAttribute('data-room-id');  //클릭한 룸 아이디
        currentRecipient = row.querySelector('td:nth-child(4)').innerText; // 현재 수신자 업데이트
        getElement('messages').innerHTML = ''; // 메시지 요소 초기화
        getElement('userEmail').innerText = currentRecipient;
        fetchMessages(chatRoomId); //해당 채팅방메세지 가져오기
        connect(); //웹소켓 연결
        getElement('myModal').style.display = 'block';
    }

    // 채팅 모달 닫기 함수
    function closeModal() {
        getElement('myModal').style.display = 'none';
        sendAdminExit();
        disconnect(); //웹소켓 연결 해제
        currentRecipient = '';
        window.chatUtils.loadChatList(activePage, inactivePage, 8, false);
    }

    // 연결 해제 함수
    function disconnect() {
        if (stompClient !== null) {
            stompClient.disconnect();
        }
        isConnected = false;
    }
</script>
</body>
</html>